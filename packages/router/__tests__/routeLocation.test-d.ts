import { describe, it, expectTypeOf } from 'vitest'
import type {
  RouteRecordName,
  ParamValue,
  ParamValueZeroOrMore,
  RouteRecordInfo,
  RouteLocationTypedList,
  RouteLocationNormalizedTypedList,
  RouteLocationNormalizedLoadedTypedList,
  RouteLocationAsRelativeTypedList,
  RouteLocationAsPathTypedList,
  RouteLocationAsStringTypedList,
  RouteLocationResolvedTypedList,
} from '../src'

// NOTE: A type allows us to make it work only in this test file
// https://github.com/microsoft/TypeScript/issues/15300
type RouteNamedMap = {
  home: RouteRecordInfo<'/', '/', Record<never, never>, Record<never, never>>
  '/[other]': RouteRecordInfo<
    '/[other]',
    '/:other',
    { other: ParamValue<true> },
    { other: ParamValue<false> },
    never
  >
  '/groups/[gid]': RouteRecordInfo<
    '/groups/[gid]',
    '/:gid',
    { gid: ParamValue<true> },
    { gid: ParamValue<false> },
    '/groups/[gid]/users' | '/groups/[gid]/users/[uid]'
  >
  '/groups/[gid]/users': RouteRecordInfo<
    '/groups/[gid]/users',
    '/:gid/users',
    { gid: ParamValue<true> },
    { gid: ParamValue<false> },
    '/groups/[gid]/users/[uid]'
  >
  '/groups/[gid]/users/[uid]': RouteRecordInfo<
    '/groups/[gid]/users/[uid]',
    '/:gid/users/:uid',
    { gid: ParamValue<true>; uid: ParamValue<true> },
    { gid: ParamValue<false>; uid: ParamValue<false> },
    never
  >
  '/[...path]': RouteRecordInfo<
    '/[...path]',
    '/:path(.*)',
    { path: ParamValue<true> },
    { path: ParamValue<false> },
    never
  >
  '/deep/nesting/works/[[files]]+': RouteRecordInfo<
    '/deep/nesting/works/[[files]]+',
    '/deep/nesting/works/:files*',
    { files?: ParamValueZeroOrMore<true> },
    { files?: ParamValueZeroOrMore<false> },
    never
  >
}

describe('Route Location types', () => {
  it('RouteLocationNormalized', () => {
    function withRoute(
      fn: (
        to: RouteLocationNormalizedTypedList<RouteNamedMap>[keyof RouteNamedMap]
      ) => void
    ): void
    function withRoute<Name extends keyof RouteNamedMap>(
      name: Name,
      fn: (to: RouteLocationNormalizedTypedList<RouteNamedMap>[Name]) => void
    ): void
    function withRoute<_Name extends RouteRecordName>(..._args: unknown[]) {}

    withRoute('/[other]', to => {
      expectTypeOf(to.params).toEqualTypeOf<{ other: string }>()
      expectTypeOf(to.params).not.toEqualTypeOf<{ gid: string }>()
      expectTypeOf(to.params).not.toEqualTypeOf<{ notExisting: string }>()
    })

    withRoute('/groups/[gid]', to => {
      expectTypeOf(to.params).toEqualTypeOf<{ gid: string }>()
      expectTypeOf(to.params).not.toEqualTypeOf<{ notExisting: string }>()
      expectTypeOf(to.params).not.toEqualTypeOf<{ other: string }>()
    })

    withRoute('/groups/[gid]/users', to => {
      expectTypeOf(to.params).toEqualTypeOf<{ gid: string }>()
      expectTypeOf(to.params).not.toEqualTypeOf<{ gid: string; uid: string }>()
      expectTypeOf(to.params).not.toEqualTypeOf<{ other: string }>()
    })

    withRoute('/groups/[gid]/users/[uid]', to => {
      expectTypeOf(to.params).toEqualTypeOf<{ gid: string; uid: string }>()
      expectTypeOf(to.params).not.toEqualTypeOf<{ notExisting: string }>()
      expectTypeOf(to.params).not.toEqualTypeOf<{ other: string }>()
    })

    withRoute('/groups/[gid]' as keyof RouteNamedMap, to => {
      // @ts-expect-error: no all params have this
      to.params.gid
      if (to.name === '/groups/[gid]') {
        to.params.gid
        // @ts-expect-error: no param other
        to.params.other
      }
    })

    withRoute(to => {
      // @ts-expect-error: not all params object have a name
      to.params.gid
      // @ts-expect-error: no route named like that
      if (to.name === '') {
      }
      if (to.name === '/groups/[gid]') {
        expectTypeOf(to.params).toEqualTypeOf<{ gid: string }>()
        // @ts-expect-error: no param other
        to.params.other
      }
    })
  })
})

// Use `interface` (not `type`) to test that the constraint works with
// interfaces that lack implicit index signatures.
// This is the exact shape generated by vue-router/vite's typed-router.d.ts.
// See: https://github.com/microsoft/TypeScript/issues/15300
interface RouteNamedMapInterface {
  '/': RouteRecordInfo<
    '/',
    '/',
    Record<never, never>,
    Record<never, never>,
    never
  >
  '/users': RouteRecordInfo<
    '/users',
    '/users',
    Record<never, never>,
    Record<never, never>,
    '/users/[id]'
  >
  '/users/[id]': RouteRecordInfo<
    '/users/[id]',
    '/users/:id',
    { id: ParamValue<true> },
    { id: ParamValue<false> },
    never
  >
}

describe('RouteMap constraint with interface (no index signatures)', () => {
  it('accepts interface-based RouteMap in all typed list types', () => {
    // These would fail with TS2344 if the constraint is
    // `extends RouteMapGeneric` because interfaces without index
    // signatures don't satisfy Record<string | symbol, ...>
    expectTypeOf<
      RouteLocationNormalizedTypedList<RouteNamedMapInterface>['/']
    >().toHaveProperty('name')
    expectTypeOf<
      RouteLocationTypedList<RouteNamedMapInterface>['/']
    >().toHaveProperty('name')
    expectTypeOf<
      RouteLocationNormalizedLoadedTypedList<RouteNamedMapInterface>['/']
    >().toHaveProperty('name')
    expectTypeOf<
      RouteLocationAsRelativeTypedList<RouteNamedMapInterface>['/']
    >().toHaveProperty('name')
    expectTypeOf<
      RouteLocationAsPathTypedList<RouteNamedMapInterface>['/']
    >().toHaveProperty('path')
    expectTypeOf<
      RouteLocationAsStringTypedList<RouteNamedMapInterface>['/']
    >().toBeString()
    expectTypeOf<
      RouteLocationResolvedTypedList<RouteNamedMapInterface>['/']
    >().toHaveProperty('name')
  })

  it('preserves type safety with interface-based RouteMap', () => {
    type NormalizedList =
      RouteLocationNormalizedTypedList<RouteNamedMapInterface>

    expectTypeOf<
      NormalizedList['/users/[id]']['name']
    >().toEqualTypeOf<'/users/[id]'>()

    expectTypeOf<NormalizedList['/users/[id]']['params']>().toEqualTypeOf<{
      id: string
    }>()

    expectTypeOf<NormalizedList['/']['params']>().toEqualTypeOf<
      Record<never, never>
    >()
  })

  it('rejects invalid route names with interface-based RouteMap', () => {
    type NormalizedList =
      RouteLocationNormalizedTypedList<RouteNamedMapInterface>

    // @ts-expect-error: '/nonexistent' is not a valid route name
    type Invalid = NormalizedList['/nonexistent']
  })
})
